-- Создаем таблицу типов неисправностей
CREATE TABLE IF NOT EXISTS fault_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code VARCHAR(20) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    device_category_id BIGINT NOT NULL,
    coverage_requirement VARCHAR(10) NOT NULL CHECK (coverage_requirement IN ('LOW', 'MEDIUM', 'HIGH')),
    gost_reference VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_fault_type_code UNIQUE (code),
    CONSTRAINT fk_fault_type_device_category 
        FOREIGN KEY (device_category_id) 
        REFERENCES device_categories(id) 
        ON DELETE CASCADE
);

-- Создаем таблицу связи методов диагностики с типами неисправностей
CREATE TABLE IF NOT EXISTS diagnostic_method_faults (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    diagnostic_method_id BIGINT NOT NULL,
    fault_type_id BIGINT NOT NULL,
    effectiveness VARCHAR(10) NOT NULL CHECK (effectiveness IN ('LOW', 'MEDIUM', 'HIGH')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_diagnostic_method_fault UNIQUE (diagnostic_method_id, fault_type_id),
    CONSTRAINT fk_dmf_diagnostic_method 
        FOREIGN KEY (diagnostic_method_id) 
        REFERENCES diagnostic_methods(id) 
        ON DELETE CASCADE,
    CONSTRAINT fk_dmf_fault_type 
        FOREIGN KEY (fault_type_id) 
        REFERENCES fault_types(id) 
        ON DELETE CASCADE
);

-- Создаем таблицу связи профилей с неисправностями
CREATE TABLE IF NOT EXISTS profile_faults (
    profile_id BIGINT NOT NULL,
    fault_type_id BIGINT NOT NULL,
    is_covered BOOLEAN DEFAULT FALSE,
    covered_methods_ids TEXT,  -- JSON-массив ID методов, покрывающих эту неисправность
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (profile_id, fault_type_id),
    CONSTRAINT fk_pf_profile 
        FOREIGN KEY (profile_id) 
        REFERENCES profiles(id) 
        ON DELETE CASCADE,
    CONSTRAINT fk_pf_fault_type 
        FOREIGN KEY (fault_type_id) 
        REFERENCES fault_types(id) 
        ON DELETE CASCADE
);

-- Создаем индексы для ускорения поиска
CREATE INDEX IF NOT EXISTS idx_fault_types_device_category ON fault_types(device_category_id);
CREATE INDEX IF NOT EXISTS idx_diagnostic_method_faults_method ON diagnostic_method_faults(diagnostic_method_id);
CREATE INDEX IF NOT EXISTS idx_diagnostic_method_faults_fault ON diagnostic_method_faults(fault_type_id);
CREATE INDEX IF NOT EXISTS idx_profile_faults_profile ON profile_faults(profile_id);
CREATE INDEX IF NOT EXISTS idx_profile_faults_fault ON profile_faults(fault_type_id);

-- Комментарии к таблицам и полям
COMMENT ON TABLE fault_types IS 'Типы неисправностей устройств';
COMMENT ON COLUMN fault_types.code IS 'Уникальный код неисправности';
COMMENT ON COLUMN fault_types.name IS 'Название неисправности';
COMMENT ON COLUMN fault_types.description IS 'Подробное описание неисправности';
COMMENT ON COLUMN fault_types.device_category_id IS 'Ссылка на категорию устройства';
COMMENT ON COLUMN fault_types.coverage_requirement IS 'Требуемый уровень покрытия (LOW, MEDIUM, HIGH)';
COMMENT ON COLUMN fault_types.gost_reference IS 'Ссылка на раздел ГОСТ';

COMMENT ON TABLE diagnostic_method_faults IS 'Связь методов диагностики с типами неисправностей';
COMMENT ON COLUMN diagnostic_method_faults.effectiveness IS 'Эффективность метода для данной неисправности';

COMMENT ON TABLE profile_faults IS 'Связь профилей с неисправностями';
COMMENT ON COLUMN profile_faults.is_covered IS 'Покрыта ли неисправность';
COMMENT ON COLUMN profile_faults.covered_methods_ids IS 'JSON-массив ID методов, покрывающих неисправность';

-- Timestamps will be handled in the application layer using @PreUpdate and @PrePersist annotations
-- in the corresponding entity classes.
